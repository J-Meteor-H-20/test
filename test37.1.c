#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
int main()
{
	short s = 0;
	int a = 10;
	printf("%d\n", sizeof(s = a + 5));//2//a+5是整型，但存储到s中，shart是两个字节；故
	printf("%d\n", s);//0//原因是sizeof中的表达式实际上是不参与运算的
	return 0;
}

//~按二进制位取反
int main()
{
	int a = 11;
	a |= (1 << 2);
	//a=11
	//00000000000000000000000000001011
	//1 
	//00000000000000000000000000000001
	//1<<2
	//00000000000000000000000000000100
	//a |= (1 << 2) 
	//00000000000000000000000000001111
	printf("%d\n", a);//15
	a &= (~(1 << 2));
	//a=15
	//00000000000000000000000000001111
	//1 << 2 
	//00000000000000000000000000000100
	//~(1 << 2) 
	//11111111111111111111111111111011
	//a &= (~(1 << 2)) 
	//00000000000000000000000000001011
	printf("%d\n", a);//11
	return 0;
}



int main()
{
	int a = 10;
	int b = 10;
	printf("a=%d\n", ++a);//11//前置++，先++，再使用
	printf("b=%d\n", b++);//10//后置++，先++，再使用
	return 0;
}






//&(取地址符)与*（间接访问操作符，又叫解引用操作符）的配合使用
void test(int arr[], int sz)
{
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		int* p = &arr[i];
		*p = 1;

	}
}

int main()
{
	int i = 0;
	int arr[] = { 0,1,2 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	test(arr,sz);
	for (i = 0; i < sz; i++)
		printf("arr[%d]=%d\n", i, arr[i]);
	return 0;
	
}





//-1(原码输出，补码操作)
//原码：10000000000000000000000000000001
//反码：11111111111111111111111111111110
//补码：11111111111111111111111111111111     
