#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//表达式求值
//表达式求值的顺序一部分是由操作符的优先级的结合性决定。同样，有些表达式在求值过程中可能需要转换类型。

//隐式类型转换
//C的整型算术运算总是至少一缺省整型的精度进行的。为了获得这个精度，表达式中的字符和短整型操作数在使用前被转换为普通型，这种类型转换为整型提升。


int main()
{
	char a = 3;
	//00000000000000000000000000000011//整形三十二个字节
	//00000011  -  a//发生截断，挑最低位的字节
	char b = 127;
	//00000000000000000000000001111111
	//01111111  - b
	//a和b如何相加 
	//进行整型提升，按照高位的符号位补齐三十二位字节
	//如a进行整形提升，00000011的最高位是0，故提升为00000000000000000000000000000011
	//b提升为                                    00000000000000000000000001111111
	//接下来直接相加运算就行得到                   00000000000000000000000010000010
	//c又是char类型，只能放8个比特位，故截断为10000010   - c
	char c = a + b;
	printf("%d\n", c);//-126
	//打印%d为整型，故c进行整型提升为11111111111111111111111110000010   -   补码
	//                            11111111111111111111111110000001   -  反码
	//                            10000000000000000000000001111110   - 原码
	return 0;

}

//整型提升的意义：表达式的整型运算在CPU的相应运算器内执行，CPU内整型运算器（ALU）的操作数的字节长度一般都是int的字节长度，通常CPU是难以实现两个8比特字节直接相加运算
//所以表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算
//




int main()
{
	char a = 0xb6;
	short b = 0xb600;
	int c = 0xb6000000;
	if (a == 0xb6)//==是运算符，故这里也是运算需要对a进行整型提升
		printf("a");
	if (b == 0xb600)
		printf("b");
	if (c == 0xb6000000)
		printf("c");
	printf("\n");
	printf("%d\n", sizeof(short));

	return 0;
}



//只要参与运算表达式就会发生整型提升
int main()
{
	char c = 1;
	printf("%u\n", sizeof(c));//1//char类型，故为一个字节
	printf("%u\n", sizeof(+c));//4//进行运算了，发生整型提升，故有四个字节
	printf("%u\n", sizeof(!c));//1//
	return 0;
}

//
//算术转换
//如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数转换为另一个操作数的类型，否则操作就无法进行，下面层次体系称为寻常算数转换。
//  long double
//  double
//  float
//  unsigned long int
//  long int 
//  unsigned int
//  int
//如果某个操作数的类型在上面这个列表中排名较低，那么首先要转换为另一个操作数的类型后执行运算。
//警告：但是算术转换要合理，要不然会有一些潜在的问题。

int main()
{
	float f = 3.14;
	int num = f;//隐式转换，会有精度丢失
	printf("%d\n", num);//其实这里我还是不太懂具体怎么转换的，留着以后复习的时候再深挖，现在只做了解
	return 0;
}




//操作符的属性
//复杂表达式的求值有三个影响因素。
//1.操作符的优先级
//2.操作符的结合性
//3.是否控制求值顺序//例如&&，||，？：这三者具有控制求值顺序//还有逗号,
//俩个相邻的操作符先执行哪个？取决于他们的优先级，如果两者的优先级相同，取决于他们的结合性
int main()
{
	int a = 10;
	int b = 20;
	int c = a + b + 3;//俩个+操作符优先级相同，但+的结合性是L-R，即为从左向右运算
	printf("%d\n", 1 * 2 + 3 * 4 + 5 * 6);
	printf("%d\n", c + --c);
	//表达式1：a*b+c*d+e*f//只能保证*的运算先于+，但三个*那个先运算还是不能确定
	//表达式2：c+--c//也同样存在问题
	return 0;

}

//代码三-非法表达式三
int main()
{
	int i = 10;
	i = i-- - --i * (i = -3) * i++ + ++i;
	printf("i=%d\n", i);//4//在这里是4，但是在不同的编译器上它的值会不同
	return 0;
}

//代码四-问题代码
int fun()
{
	static int count = 1;
	return count++;
}
int main()
{
	int answer;
	answer = fun() - fun() * fun();//这里fun()函数的调用顺序不一样，结果也就不一样了
	printf("%d\n", answer);//-5
}

int main()
{
	int i = 1;
	int a = (++i) + (++i) + (++i);
	printf("%d\n", a);//12//在linus操作系统中的执行结果为10
	return 0;
}

//总结：我们写出的表达式如果不能通过操作符的属性确定唯一的计算机路径，那么这个表达式就是存在问题的